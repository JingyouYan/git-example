//
// Created by 26247 on 2024/10/20.
//
#include <stdio.h>

int main(void){
    int a, b;
    scanf("%d%d", &a, &b);
    if (!(a >= 1 && a <= 2000000000 && b >= 1 && b <= 2000000000)) {
        return 1;
    }

    /*还有很大的进步空间：首先，求最大公因数用for循环应该是i--相对合适，找到即可break迅速退出循环；
     *
     *其次，用while循环结合欧几里得算法会使得计算简便很多，不用再另外引入其它变量；可以考虑在开头就进行a,b值的互化实现a>= b
     *
     */

    int n, m;
    if (a >= b) {
        n = b;
        m = a;
    } else {
        n = a;
        m = b;
    }

    // for(;n!=0;)
    while (n != 0) {
        int temp = n;
        n = m % n;
        m = temp;
    }

    printf("%d", m);
    return 0;
    //
    // //注意gcd变量的作用范围
    // int gcd = 1;
    //
    // //区别于求质数验证的是存在性问题，这里求的是一个·绝对的量，需要将较小的那个数的所有因数历遍
    // // for (int i = 2; i <= a; i++) {
    // //     if (n % i == 0 && m % i == 0) {
    // //         gcd = i;
    // //     }
    // // }
    //
    // //上面的这种写法由于历遍了所有1到n的数，会出现超时的现象；
    // //改进方法：利用已有的求出的i，进行m % (a / i) == 0的判断，大大提高计算效率
    // //充分利用已有的  条件进行循环计算
    // if (m % n == 0) {
    //     gcd = n;
    // } else {
    //     //特别小心这里写的参量：m,n是有意义有大小的量，不要写着写着有变成a,b去了
    //     for (int i = 2; i * i <= n; i++) {
    //         if (n % i == 0 && m % i == 0 && i > gcd) {
    //             gcd = i;
    //         } else if (n % i == 0 && m % (n / i) == 0 && (n / i) > gcd) {
    //             gcd = n / i;
    //         }
    //     }
    // }

    // printf("%d", gcd);
    // return 0;
}
